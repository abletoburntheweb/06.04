# -*- coding: utf-8 -*-
"""Копия блокнота "Копия блокнота "study_lab_6.ipynb""

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hjFvqcaOemvPOpK1TWbW88uvEy_vsmKx

Рассмотрим простейшее прогнозирование количества продаж и проведем анализ достоверности планирования продаж на примере элементов одежды.
"""

# Импортируем модуль random для выполнения операций с генерацией случайных чисел и прочими случайными операциями.
import random

# Импортируем библиотеку numpy (сокращение от "Numerical Python") для эффективной работы с массивами и выполнения математических операций на них.
import numpy as np

# Импортируем библиотеку pandas для работы с данными в виде таблиц и датафреймов, предоставляя удобные инструменты для анализа и манипуляций данными.
import pandas as pd

# Импортируем библиотеку matplotlib.pyplot для создания графиков и визуализации данных, предоставляя множество функций для построения различных видов графиков.
import matplotlib.pyplot as plt

# Импортируем модуль warnings для управления предупреждениями во время выполнения программы.
# В этом фрагменте кода устанавливается игнорирование предупреждений типа FutureWarning, что может быть полезным для скрытия определенных сообщений о будущих изменениях в библиотеках.
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

"""Создадим класс для описания товара. В конструкторе для класса будем принимать название продукта и количество этого товара, если это значение не будет передано, то оно будет генерироваться самостоятельно. Также добавим в класс методы для вычисления вспомогательных значений – среднее арифметическое продаж и среднеквадратичное отклонение."""

class Product:
    """
    Класс Product представляет товар с указанным именем и количеством (по умолчанию None).
    """

    def __init__(self, name, count=None):
        self.name = name
        if count is not None:
            self.count = count
        else:
            min_rand = random.randint(250, 500)
            delt_rand = 100
            self.count = np.random.normal(min_rand, delt_rand, 12)
            # подробнее: https://numpy.org/doc/2.1/reference/random/generated/numpy.random.normal.html
            # и тут: https://miptstats.github.io/courses/python/07_random.html

            # округление
            self.count = np.round(self.count, 0)

    def __str__(self):
        """
        Возвращает строковое представление товара, включая его имя и количество за каждый из 12 месяцев.
        """
        return f'{self.name}: {[i for i in self.count]}'

    def __repr__(self):
        """
        Возвращает строковое представление товара, включая его имя и количество за каждый из 12 месяцев.
        """
        return f'{self.name}: {[i for i in self.count]}'

    def to_dict(self):
        """
        Преобразует товар в словарь, где ключ - имя товара, а значение - список количества за каждый из 12 месяцев.
        """
        return {
            self.name: self.count
        }

    def sum(self):
        """
        Возвращает общее количество проданного товара за 12 месяцев.
        """
        return sum(self.count)

    def avg(self):
        """
        Возвращает среднее количество проданного товара за 12 месяцев.
        """
        return round(sum(self.count) / len(self.count), 0)

    def msd(self):
        """
        Возвращает среднеквадратичное отклонение (СКО) количества товара за 12 месяцев.
        """
        avg_value = self.avg()
        upper_value = sum([(v - avg_value) ** 2 for v in self.count])
        msd_square = upper_value / (len(self.count) - 1)
        return round(msd_square ** 0.5, 0)

"""Создадим список товаров."""

# Создаем список товаров.
products = [
    Product(name='Футболки'),
    Product(name='Джинсы'),
    Product(name='Платья'),
    Product(name='Пальто'),
    Product(name='Шорты'),
    Product(name='Юбки'),
    Product(name='Рубашки'),
    Product(name='Свитера'),
    Product(name='Брюки'),
    Product(name='Жакеты')
]
# print(products)
products

"""Полученный набор товаров и их количество продаж за 12 месяцев представим в лучшем виде"""

def convert_list_products_to_dict(p_list: list):
    """
    Конвертирует лист продуктов в словарь для визуализации.
    """
    result = {}
    for p in p_list:
        result[p.name] = p.count
    return result

df = pd.DataFrame(convert_list_products_to_dict(products))
# print(df)
df

"""Представим эти данные на графике"""

# Покажем количество товаров на графике, отображая данные для каждого товара.
for product in products:
    plt.plot([i for i in range(12)], product.count, label=product.name)

plt.legend(bbox_to_anchor=(1, 1))
plt.show()

"""Далее надо сгенерировать количество продаж для кадого товара на 13й месяц. Спрогнозированное количество продаж на 13й месяц будет равняться среднему значению плюс случайное значение в диапазоне от нуля до среднеквадратичного отклонения.

Вычислим среднее арифметическое количество продаж в месяц для каждого товара (оценка тренда).
"""

# Вычислим средние значения для каждого товара из списка и сохраним их в список p0.
p0 = [product.avg() for product in products]

# Создадим список строк, в которых каждая строка содержит имя продукта и его среднее значение,
# используя списки p0 и products в соответствии с итерацией через zip().
# print([f'{p.name}: {p_avg}' for p_avg, p in zip(p0, products)])
[f'{p.name}: {p_avg}' for p_avg, p in zip(p0, products)]

"""Вычислим среднеквадратичное отклонение продаж по каждому товару (оценка СКО)

![population_standard_deviation.svg](data:image/svg+xml;base64,PHN2ZyB4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgd2lkdGg9IjI3OHB4IiBoZWlnaHQ9IjEwNnB4IiB2aWV3Qm94PSIwIC0zNTgxLjMgMTQ0MzkuNiA1NTAyLjYiIHJvbGU9ImltZyIgZm9jdXNhYmxlPSJmYWxzZSIgc3R5bGU9InZlcnRpY2FsLWFsaWduOiAtNC40NjJleDsiIGFyaWEtaGlkZGVuPSJ0cnVlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxnIHN0cm9rZT0iY3VycmVudENvbG9yIiBmaWxsPSJjdXJyZW50Q29sb3IiIHN0cm9rZS13aWR0aD0iMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgLTEgMCAwKSI+PHBhdGggc3Ryb2tlLXdpZHRoPSIxMCIgdHJhbnNmb3JtPSJzY2FsZSgxLjczKSIgZD0iTTE4NCAtMTFRMTE2IC0xMSA3NCAzNFQzMSAxNDdRMzEgMjQ3IDEwNCAzMzNUMjc0IDQzMFEyNzUgNDMxIDQxNCA0MzFINTUyUTU1MyA0MzAgNTU1IDQyOVQ1NTkgNDI3VDU2MiA0MjVUNTY1IDQyMlQ1NjcgNDIwVDU2OSA0MTZUNTcwIDQxMlQ1NzEgNDA3VDU3MiA0MDFRNTcyIDM1NyA1MDcgMzU3UTUwMCAzNTcgNDkwIDM1N1Q0NzYgMzU4SDQxNkw0MjEgMzQ4UTQzOSAzMTAgNDM5IDI2M1E0MzkgMTUzIDM1OSA3MVQxODQgLTExWk0zNjEgMjc4UTM2MSAzNTggMjc2IDM1OFExNTIgMzU4IDExNSAxODRRMTE0IDE4MCAxMTQgMTc4UTEwNiAxNDEgMTA2IDExN1ExMDYgNjcgMTMxIDQ3VDE4OCAyNlEyNDIgMjYgMjg3IDczUTMxNiAxMDMgMzM0IDE1M1QzNTYgMjMzVDM2MSAyNzhaIj48L3BhdGg+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ3OCwwKSI+PHBhdGggc3Ryb2tlLXdpZHRoPSIxMCIgdHJhbnNmb3JtPSJzY2FsZSgxLjczKSIgZD0iTTU2IDM0N1E1NiAzNjAgNzAgMzY3SDcwN1E3MjIgMzU5IDcyMiAzNDdRNzIyIDMzNiA3MDggMzI4TDM5MCAzMjdINzJRNTYgMzMyIDU2IDM0N1pNNTYgMTUzUTU2IDE2OCA3MiAxNzNINzA4UTcyMiAxNjMgNzIyIDE1M1E3MjIgMTQwIDcwNyAxMzNINzBRNTYgMTQwIDU2IDE1M1oiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzMxMywwKSI+PHBhdGggc3Ryb2tlLXdpZHRoPSIxMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwzNDQpIHNjYWxlKDEuNzMpIiBkPSJNOTgzIDE3MzlROTg4IDE3NTAgMTAwMSAxNzUwUTEwMDggMTc1MCAxMDEzIDE3NDVUMTAyMCAxNzMzUTEwMjAgMTcyNiA3NDIgMjQ0VDQ2MCAtMTI0MVE0NTggLTEyNTAgNDM5IC0xMjUwSDQzNlE0MjQgLTEyNTAgNDI0IC0xMjQ4TDQxMCAtMTE2NlEzOTUgLTEwODMgMzY3IC05MjBUMzEyIC02MDFMMjAxIDQ0TDEzNyAtODNMMTExIC01N0wxODcgOTZMMjY0IDI0N1EyNjUgMjQ2IDM2OSAtMzU3UTQ3MCAtOTU4IDQ3MyAtOTYzTDcyNyAzODRROTc5IDE3MjkgOTgzIDE3MzlaIj48L3BhdGg+PHJlY3Qgc3Ryb2tlPSJub25lIiB3aWR0aD0iOTM4NyIgaGVpZ2h0PSIxMDMiIHg9IjE3MzgiIHk9IjMyODUiPjwvcmVjdD48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzM4LDApIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDcsMCkiPjxyZWN0IHN0cm9rZT0ibm9uZSIgd2lkdGg9Ijg5NzEiIGhlaWdodD0iMTAzIiB4PSIwIiB5PSIzODAiPjwvcmVjdD48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMDMsMTE3MCkiPjxwYXRoIHN0cm9rZS13aWR0aD0iMTAiIHRyYW5zZm9ybT0ic2NhbGUoMS43MykiIGQ9Ik02MSA3NDhRNjQgNzUwIDQ4OSA3NTBIOTEzTDk1NCA2NDBROTY1IDYwOSA5NzYgNTc5VDk5MyA1MzNUOTk5IDUxNkg5NzlMOTU5IDUxN1E5MzYgNTc5IDg4NiA2MjFUNzc3IDY4MlE3MjQgNzAwIDY1NSA3MDVUNDM2IDcxMEgzMTlRMTgzIDcxMCAxODMgNzA5UTE4NiA3MDYgMzQ4IDQ4NFQ1MTEgMjU5UTUxNyAyNTAgNTEzIDI0NEw0OTAgMjE2UTQ2NiAxODggNDIwIDEzNFQzMzAgMjdMMTQ5IC0xODdRMTQ5IC0xODggMzYyIC0xODhRMzg4IC0xODggNDM2IC0xODhUNTA2IC0xODlRNjc5IC0xODkgNzc4IC0xNjJUOTM2IC00M1E5NDYgLTI3IDk1OSA2SDk5OUw5MTMgLTI0OUw0ODkgLTI1MFE2NSAtMjUwIDYyIC0yNDhRNTYgLTI0NiA1NiAtMjM5UTU2IC0yMzQgMTE4IC0xNjFRMTg2IC04MSAyNDUgLTExTDQyOCAyMDZRNDI4IDIwNyAyNDIgNDYyTDU3IDcxN0w1NiA3MjhRNTYgNzQ0IDYxIDc0OFoiPjwvcGF0aD48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODM1LDApIj48cGF0aCBzdHJva2Utd2lkdGg9IjEwIiB0cmFuc2Zvcm09InNjYWxlKDEuNzMpIiBkPSJNOTQgMjUwUTk0IDMxOSAxMDQgMzgxVDEyNyA0ODhUMTY0IDU3NlQyMDIgNjQzVDI0NCA2OTVUMjc3IDcyOVQzMDIgNzUwSDMxNUgzMTlRMzMzIDc1MCAzMzMgNzQxUTMzMyA3MzggMzE2IDcyMFQyNzUgNjY3VDIyNiA1ODFUMTg0IDQ0M1QxNjcgMjUwVDE4NCA1OFQyMjUgLTgxVDI3NCAtMTY3VDMxNiAtMjIwVDMzMyAtMjQxUTMzMyAtMjUwIDMxOCAtMjUwSDMxNUgzMDJMMjc0IC0yMjZRMTgwIC0xNDEgMTM3IC0xNFQ5NCAyNTBaIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1MTcsMCkiPjxwYXRoIHN0cm9rZS13aWR0aD0iMTAiIHRyYW5zZm9ybT0ic2NhbGUoMS43MykiIGQ9Ik01MiAyODlRNTkgMzMxIDEwNiAzODZUMjIyIDQ0MlEyNTcgNDQyIDI4NiA0MjRUMzI5IDM3OVEzNzEgNDQyIDQzMCA0NDJRNDY3IDQ0MiA0OTQgNDIwVDUyMiAzNjFRNTIyIDMzMiA1MDggMzE0VDQ4MSAyOTJUNDU4IDI4OFE0MzkgMjg4IDQyNyAyOTlUNDE1IDMyOFE0MTUgMzc0IDQ2NSAzOTFRNDU0IDQwNCA0MjUgNDA0UTQxMiA0MDQgNDA2IDQwMlEzNjggMzg2IDM1MCAzMzZRMjkwIDExNSAyOTAgNzhRMjkwIDUwIDMwNiAzOFQzNDEgMjZRMzc4IDI2IDQxNCA1OVQ0NjMgMTQwUTQ2NiAxNTAgNDY5IDE1MVQ0ODUgMTUzSDQ4OVE1MDQgMTUzIDUwNCAxNDVRNTA0IDE0NCA1MDIgMTM0UTQ4NiA3NyA0NDAgMzNUMzMzIC0xMVEyNjMgLTExIDIyNyA1MlExODYgLTEwIDEzMyAtMTBIMTI3UTc4IC0xMCA1NyAxNlQzNSA3MVEzNSAxMDMgNTQgMTIzVDk5IDE0M1ExNDIgMTQzIDE0MiAxMDFRMTQyIDgxIDEzMCA2NlQxMDcgNDZUOTQgNDFMOTEgNDBROTEgMzkgOTcgMzZUMTEzIDI5VDEzMiAyNlExNjggMjYgMTk0IDcxUTIwMyA4NyAyMTcgMTM5VDI0NSAyNDdUMjYxIDMxM1EyNjYgMzQwIDI2NiAzNTJRMjY2IDM4MCAyNTEgMzkyVDIxNyA0MDRRMTc3IDQwNCAxNDIgMzcyVDkzIDI5MFE5MSAyODEgODggMjgwVDcyIDI3OEg1OFE1MiAyODQgNTIgMjg5WiI+PC9wYXRoPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDk5OCwtMjYwKSI+PHBhdGggc3Ryb2tlLXdpZHRoPSIxMCIgdHJhbnNmb3JtPSJzY2FsZSgxLjIyMykiIGQ9Ik0xODQgNjAwUTE4NCA2MjQgMjAzIDY0MlQyNDcgNjYxUTI2NSA2NjEgMjc3IDY0OVQyOTAgNjE5UTI5MCA1OTYgMjcwIDU3N1QyMjYgNTU3UTIxMSA1NTcgMTk4IDU2N1QxODQgNjAwWk0yMSAyODdRMjEgMjk1IDMwIDMxOFQ1NCAzNjlUOTggNDIwVDE1OCA0NDJRMTk3IDQ0MiAyMjMgNDE5VDI1MCAzNTdRMjUwIDM0MCAyMzYgMzAxVDE5NiAxOTZUMTU0IDgzUTE0OSA2MSAxNDkgNTFRMTQ5IDI2IDE2NiAyNlExNzUgMjYgMTg1IDI5VDIwOCA0M1QyMzUgNzhUMjYwIDEzN1EyNjMgMTQ5IDI2NSAxNTFUMjgyIDE1M1EzMDIgMTUzIDMwMiAxNDNRMzAyIDEzNSAyOTMgMTEyVDI2OCA2MVQyMjMgMTFUMTYxIC0xMVExMjkgLTExIDEwMiAxMFQ3NCA3NFE3NCA5MSA3OSAxMDZUMTIyIDIyMFExNjAgMzIxIDE2NiAzNDFUMTczIDM4MFExNzMgNDA0IDE1NiA0MDRIMTU0UTEyNCA0MDQgOTkgMzcxVDYxIDI4N1E2MCAyODYgNTkgMjg0VDU4IDI4MVQ1NiAyNzlUNTMgMjc4VDQ5IDI3OFQ0MSAyNzhIMjdRMjEgMjg0IDIxIDI4N1oiPjwvcGF0aD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ1MDAsMCkiPjxwYXRoIHN0cm9rZS13aWR0aD0iMTAiIHRyYW5zZm9ybT0ic2NhbGUoMS43MykiIGQ9Ik04NCAyMzdUODQgMjUwVDk4IDI3MEg2NzlRNjk0IDI2MiA2OTQgMjUwVDY3OSAyMzBIOThRODQgMjM3IDg0IDI1MFoiPjwvcGF0aD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjIzOSwwKSI+PHBhdGggc3Ryb2tlLXdpZHRoPSIxMCIgdHJhbnNmb3JtPSJzY2FsZSgxLjczKSIgZD0iTTU4IC0yMTZRNDQgLTIxNiAzNCAtMjA4VDIzIC0xODZRMjMgLTE3NiA5NiAxMTZUMTczIDQxNFExODYgNDQyIDIxOSA0NDJRMjMxIDQ0MSAyMzkgNDM1VDI0OSA0MjNUMjUxIDQxM1EyNTEgNDAxIDIyMCAyNzlUMTg3IDE0MlExODUgMTMxIDE4NSAxMDdWOTlRMTg1IDI2IDI1MiAyNlEyNjEgMjYgMjcwIDI3VDI4NyAzMVQzMDIgMzhUMzE1IDQ1VDMyNyA1NVQzMzggNjVUMzQ4IDc3VDM1NiA4OFQzNjUgMTAwTDM3MiAxMTBMNDA4IDI1M1E0NDQgMzk1IDQ0OCA0MDRRNDYxIDQzMSA0OTEgNDMxUTUwNCA0MzEgNTEyIDQyNFQ1MjMgNDEyVDUyNSA0MDJMNDQ5IDg0UTQ0OCA3OSA0NDggNjhRNDQ4IDQzIDQ1NSAzNVQ0NzYgMjZRNDg1IDI3IDQ5NiAzNVE1MTcgNTUgNTM3IDEzMVE1NDMgMTUxIDU0NyAxNTJRNTQ5IDE1MyA1NTcgMTUzSDU2MVE1ODAgMTUzIDU4MCAxNDRRNTgwIDEzOCA1NzUgMTE3VDU1NSA2M1Q1MjMgMTNRNTEwIDAgNDkxIC04UTQ4MyAtMTAgNDY3IC0xMFE0NDYgLTEwIDQyOSAtNFQ0MDIgMTFUMzg1IDI5VDM3NiA0NFQzNzQgNTFMMzY4IDQ1UTM2MiAzOSAzNTAgMzBUMzI0IDEyVDI4OCAtNFQyNDYgLTExUTE5OSAtMTEgMTUzIDEyTDEyOSAtODVRMTA4IC0xNjcgMTA0IC0xODBUOTIgLTIwMlE3NiAtMjE2IDU4IC0yMTZaIj48L3BhdGg+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDcyOTEsMCkiPjxwYXRoIHN0cm9rZS13aWR0aD0iMTAiIHRyYW5zZm9ybT0ic2NhbGUoMS43MykiIGQ9Ik02MCA3NDlMNjQgNzUwUTY5IDc1MCA3NCA3NTBIODZMMTE0IDcyNlEyMDggNjQxIDI1MSA1MTRUMjk0IDI1MFEyOTQgMTgyIDI4NCAxMTlUMjYxIDEyVDIyNCAtNzZUMTg2IC0xNDNUMTQ1IC0xOTRUMTEzIC0yMjdUOTAgLTI0NlE4NyAtMjQ5IDg2IC0yNTBINzRRNjYgLTI1MCA2MyAtMjUwVDU4IC0yNDdUNTUgLTIzOFE1NiAtMjM3IDY2IC0yMjVRMjIxIC02NCAyMjEgMjUwVDY2IDcyNVE1NiA3MzcgNTUgNzM4UTU1IDc0NiA2MCA3NDlaIj48L3BhdGg+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjgxLDg0MikiPjxwYXRoIHN0cm9rZS13aWR0aD0iMTAiIHRyYW5zZm9ybT0ic2NhbGUoMS4yMjMpIiBkPSJNMTA5IDQyOVE4MiA0MjkgNjYgNDQ3VDUwIDQ5MVE1MCA1NjIgMTAzIDYxNFQyMzUgNjY2UTMyNiA2NjYgMzg3IDYxMFQ0NDkgNDY1UTQ0OSA0MjIgNDI5IDM4M1QzODEgMzE1VDMwMSAyNDFRMjY1IDIxMCAyMDEgMTQ5TDE0MiA5M0wyMTggOTJRMzc1IDkyIDM4NSA5N1EzOTIgOTkgNDA5IDE4NlYxODlINDQ5VjE4NlE0NDggMTgzIDQzNiA5NVQ0MjEgM1YwSDUwVjE5VjMxUTUwIDM4IDU2IDQ2VDg2IDgxUTExNSAxMTMgMTM2IDEzN1ExNDUgMTQ3IDE3MCAxNzRUMjA0IDIxMVQyMzMgMjQ0VDI2MSAyNzhUMjg0IDMwOFQzMDUgMzQwVDMyMCAzNjlUMzMzIDQwMVQzNDAgNDMxVDM0MyA0NjRRMzQzIDUyNyAzMDkgNTczVDIxMiA2MTlRMTc5IDYxOSAxNTQgNjAyVDExOSA1NjlUMTA5IDU1MFExMDkgNTQ5IDExNCA1NDlRMTMyIDU0OSAxNTEgNTM1VDE3MCA0ODlRMTcwIDQ2NCAxNTQgNDQ3VDEwOSA0MjlaIj48L3BhdGg+PC9nPjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzcxMywtMTE4NykiPjxwYXRoIHN0cm9rZS13aWR0aD0iMTAiIHRyYW5zZm9ybT0ic2NhbGUoMS43MykiIGQ9Ik0yMzQgNjM3UTIzMSA2MzcgMjI2IDYzN1EyMDEgNjM3IDE5NiA2MzhUMTkxIDY0OVExOTEgNjc2IDIwMiA2ODJRMjA0IDY4MyAyOTkgNjgzUTM3NiA2ODMgMzg3IDY4M1Q0MDEgNjc3UTYxMiAxODEgNjE2IDE2OEw2NzAgMzgxUTcyMyA1OTIgNzIzIDYwNlE3MjMgNjMzIDY1OSA2MzdRNjM1IDYzNyA2MzUgNjQ4UTYzNSA2NTAgNjM3IDY2MFE2NDEgNjc2IDY0MyA2NzlUNjUzIDY4M1E2NTYgNjgzIDY4NCA2ODJUNzY3IDY4MFE4MTcgNjgwIDg0MyA2ODFUODczIDY4MlE4ODggNjgyIDg4OCA2NzJRODg4IDY1MCA4ODAgNjQyUTg3OCA2MzcgODU4IDYzN1E3ODcgNjMzIDc2OSA1OTdMNjIwIDdRNjE4IDAgNTk5IDBRNTg1IDAgNTgyIDJRNTc5IDUgNDUzIDMwNUwzMjYgNjA0TDI2MSAzNDRRMTk2IDg4IDE5NiA3OVEyMDEgNDYgMjY4IDQ2SDI3OFEyODQgNDEgMjg0IDM4VDI4MiAxOVEyNzggNiAyNzIgMEgyNTlRMjI4IDIgMTUxIDJRMTIzIDIgMTAwIDJUNjMgMlQ0NiAxUTMxIDEgMzEgMTBRMzEgMTQgMzQgMjZUMzkgNDBRNDEgNDYgNjIgNDZRMTMwIDQ5IDE1MCA4NVExNTQgOTEgMjIxIDM2MkwyODkgNjM0UTI4NyA2MzUgMjM0IDYzN1oiPjwvcGF0aD48L2c+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPg==)

N = размер выборки

Xi = каждый элемент выборки

μ = среднее значение для совокупности

σ =	среднеквадратическое отклонение

См.: https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B5%D0%B4%D0%BD%D0%B5%D0%BA%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BE%D1%82%D0%BA%D0%BB%D0%BE%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5
"""

# Вычислим значения СКО (среднеквадратичного отклонения) для каждого товара в списке products.
msd_products = [product.msd() for product in products]

# Создадим список строк, в которых каждая строка содержит имя товара и его СКО значение,
# используя списки msd_products и products в соответствии с итерацией через zip().
# print([f'{product.name}: {msd_value}' for msd_value, product in zip(msd_products, products)])
[f'{product.name}: {msd_value}' for msd_value, product in zip(msd_products, products)]

"""Сгенерируем данные о продажах за 13-й месяц (каждый раз генерируются новые значения)"""

# Сгенерируем предсказанные значения, добавляя к средним значениям p0 случайный шум
# с нормальным распределением. Это позволит смоделировать случайную изменчивость данных.
predict_values = np.round(p0 + np.random.normal(0, msd_products, len(msd_products)), 1)
# print(predict_values)
predict_values

"""Подставим сгенерированные значения в созданную ранее таблицу данных"""

# Обновляем значения 'count' для продуктов в соответствии с предсказанными значениями 'predict_values'.
for product, predict_value in zip(products, predict_values):
    product.count = np.append(product.count, predict_value)
# print(products)
products

# Создаем DataFrame (таблицу) на основе словаря, полученного из списка продуктов 'products'
# с помощью функции 'convert_list_products_to_dict'.
df = pd.DataFrame(convert_list_products_to_dict(products))
# print(df)
df

for product in products:
    plt.plot([i for i in range(13)], product.count, label=product.name)
plt.legend(bbox_to_anchor=(1, 1))
plt.show()

"""После получения данных о продажах за 13 месяцев перейдем к оценке корректности планирования продаж, что включает в себя проверку трех условий:

1. Продажи (обозначаемые как Xi) должны быть близки к их среднему значению, что указывает на стабильность продаж.
2. Прогнозируемые значения (Xi) не должны быть слишком близкими к нулю, что подтверждает адекватность выбранного периода для прогнозирования.
3. В данных не должно быть нулевых значений, что гарантирует правильную выборку периодичности анализа данных.

========================================================



УСЛОВИЕ №1

Продажи (обозначаемые как Xi) должны быть близки к их среднему значению, что указывает на стабильность продаж
"""

# Преобразуем списки p0 и msd_products в массивы NumPy для выполнения операций с массивами.
p0_np = np.array(p0)
msd_np = np.array(msd_products)

# Создаем DataFrame 'products_df' на основе словаря, полученного из списка продуктов 'products'.
products_df = pd.DataFrame(convert_list_products_to_dict(products))

# Вычисляем 'condition_one', сравнивая каждое значение в 'products_df' с условием.
# Условие считается истинным, если разница между значением 'products_df' и 'p0_np' меньше 2-х раз 'msd_np'.
condition_one = products_df - p0_np < (2 * msd_np)
condition_one

# Вызываем метод '.all()' для DataFrame 'condition_one', чтобы проверить,
# выполняется ли условие ('True') для всех элементов в DataFrame.
condition_one.all()

"""
========================================================



УСЛОВИЕ №2

Прогнозируемые значения (Xi) не должны быть слишком близкими к нулю, что подтверждает адекватность выбранного периода для прогнозирования"""

# Создаем новое условие 'condition_two', сравнивая каждое значение в 'p0_np' с условием.
# Условие считается истинным, если значение в 'p0_np' больше чем два раза 'msd_np'.
condition_two = p0_np > (2 * msd_np)
condition_two

[f'{product.name}: {condition_value}' for product, condition_value in zip(products, condition_two)]

"""
========================================================



УСЛОВИЕ №3

В данных не должно быть нулевых значений, что гарантирует правильную выборку периодичности анализа данных
"""

# Создаем список строк, в которых каждая строка содержит имя продукта и результат 'condition_three'.
condition_three = products_df > 0
condition_three

# Вызываем метод '.all()' для DataFrame 'condition_three', чтобы проверить,
# выполняется ли условие ('True') для всех элементов в DataFrame.
condition_three.all()

"""СВОДНЫЙ РЕЗУЛЬТАТ ПО ВСЕМ ТРЕМ УСЛОВИЯМ"""

def get_color_by_condition(c1, c2, c3):
    """
    Функция определяет уровень достоверности на основе трех условий.

    Возвращает:
    - str: Уровень достоверности, который может быть "Зеленый", "Желтый", "Оранжевый" или "Красный".
    """
    if c1 and c2 and c3:
        return "Зеленый"
    elif (not c1 and c2 and c3) or (c1 and not c2 and c3):
        return "Желтый"
    elif not c1 and not c2 and c3:
        return "Оранжевый"
    else:
        return "Красный"

# Создаем заголовок таблицы 'table_header' с названиями столбцов.
table_header = ["Товар", "Уровень достоверности", "Условие 1", "Условие 2", "Условие 3"]

# Создаем пустой список 'table_data' для хранения данных, которые будут добавлены в таблицу.
table_data = []

# Вычисляем результаты условий 'condition_one', 'condition_two' и 'condition_three'.
condition_one_result = condition_one.all()
condition_two_result = condition_two
condition_three_result = condition_three.all()

# В цикле добавляем данные о продуктах и их уровне достоверности в список 'table_data'.
for i in range(len(products)):
    table_data.append({
        "Товар": products[i].name,
        "Уровень достоверности": get_color_by_condition(condition_one_result[i], condition_two_result[i], condition_three_result[i]),
        "Условие 1": condition_one_result[i],
        "Условие 2": condition_two_result[i],
        "Условие 3": condition_three_result[i]
    })

# Создаем DataFrame 'table' на основе данных из 'table_data' и с заданным заголовком 'table_header'.
table = pd.DataFrame(table_data, columns=table_header)

# Выводим полученную таблицу 'table'.
# table

def color_rows_by_reliability(val):
    if val == "Зеленый":
        return 'background-color: green'
    elif val == "Желтый":
        return 'background-color: yellow'
    elif val == "Оранжевый":
        return 'background-color: orange'
    elif val == "Красный":
        return 'background-color: red'
    else:
        return ''

table_style = table["Уровень достоверности"].to_frame().applymap(lambda x: color_rows_by_reliability(x))
styled_table = table.style.apply(lambda x: table_style, axis=None)
styled_table